================================================================================================================================================================================================================================================

수정이 필요한 부분을 수정해서 파일별로 다시보내줘.
기존 주석을 유지해줘.
reanme 을 했을때 실제 파일도 변경되도록 수정해줘.

================================================================================================================================================================================================================================================

// extension.ts

import * as vscode from "vscode";
import { createBookmarkProvider } from "./providers/BookmarkProvider.js";
import { createBookmarkCommand } from "./commands/BookmarkCommand.js";
import type { BookmarkSystemItem } from "./models/BookmarkSystemItem.js";

// 추가 리스너 설정 ---------------------------------------------------------------------
const setupAdditionalListeners = (
	provider: ReturnType<typeof createBookmarkProvider>,
	commandManager: ReturnType<typeof createBookmarkCommand>,
	treeView: vscode.TreeView<BookmarkSystemItem>
): vscode.Disposable[] => {
	const listeners: vscode.Disposable[] = [];

	// 선택 변경 → 캐시 동기화
	const selListener = treeView.onDidChangeSelection(e => {
		console.debug("[SIMPLE-BOOKMARK.selectionChanged]", e.selection.length);
		commandManager.updateSelectedBookmark(e.selection as BookmarkSystemItem[]);
	});

	// 워크스페이스 폴더 변경 감지 → 북마크 갱신
	const workspaceListener = vscode.workspace.onDidChangeWorkspaceFolders(() => {
		console.debug("[SIMPLE-BOOKMARK.workspaceChanged]");
		vscode.window.showInformationMessage("Workspace changed. SIMPLE-BOOKMARK bookmarks may need to be refreshed.");
		provider.refresh();
	});

	// 확장 설정 변경 감지 → 북마크 갱신
	const configListener = vscode.workspace.onDidChangeConfiguration(e => {
		if (e.affectsConfiguration("SIMPLE-BOOKMARK")) {
			console.debug("[SIMPLE-BOOKMARK.configChanged]");
			provider.refresh();
		}
	});

	// 파일 저장 이벤트 감지 (로그)
	const saveListener = vscode.workspace.onDidSaveTextDocument((doc) => {
		console.debug("[SIMPLE-BOOKMARK.savebookmark]", doc.uri.fsPath);
	});

	listeners.push(selListener, workspaceListener, configListener, saveListener);
	return listeners;
};

// 활성화 훅 --------------------------------------------------------------------------------
export const activate = (
	context: vscode.ExtensionContext
): void => {
	console.debug("[SIMPLE-BOOKMARK.activate] start");
	const workspaceRoot = (
		vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0
		? vscode.workspace.workspaceFolders[0].uri.fsPath
		: undefined
	);

	if (!workspaceRoot) {
		vscode.window.showWarningMessage("SIMPLE-BOOKMARK requires an open workspace to function properly.");
		console.debug("[SIMPLE-BOOKMARK.activate] no workspace");
		return;
	}

	const provider = createBookmarkProvider(workspaceRoot);
	const commandManager = createBookmarkCommand(provider, context);
	const commands = commandManager.registerCommands();

	const treeView = vscode.window.createTreeView("SIMPLE-BOOKMARK", {
		treeDataProvider: provider,
		canSelectMany: true,
		showCollapseAll: true
	});

	const additionalListeners = setupAdditionalListeners(provider, commandManager, treeView);

	context.subscriptions.push(
		treeView,
		...commands,
		...additionalListeners,
		{ dispose: () => provider.dispose() }
	);
	console.debug("[SIMPLE-BOOKMARK.activate] ready");
};

// 비활성화 훅 ---------------------------------------------------------------------------------
export const deactivate = (): void => {
	console.debug("[SIMPLE-BOOKMARK.deactivate]");
};


================================================================================================================================================================================================================================================

// utils/BookmarkPathUtil.ts

import * as path from "path";
import * as fs from "fs";

// 파일명 그대로 반환 (덮어쓰기 허용) ----------------------------------------------------
export const getTargetFileName = (dir: string, fileName: string): string => {
	return fileName;
};

// 워크스페이스 내 .bookmark 폴더 경로 반환 ----------------------------------------------
export const getBookmarkPath = (workspaceRoot: string): string => {
	return path.join(workspaceRoot, ".bookmark");
};

// 주어진 경로가 .bookmark 폴더 내부에 포함되는지 확인 ------------------------------------
export const isWithinBookmark = (itemPath: string, bookmarkPath: string): boolean => {
	return itemPath.startsWith(bookmarkPath);
};

// 파일명 유효성 검사 ---------------------------------------------------------------------
export const validateFileName = (fileName: string): string | null => {
	if (!fileName || !fileName.trim()) {
		return "File name cannot be empty";
	}
	if (fileName.includes("/") || fileName.includes("\\")) {
		return "Invalid characters in file name";
	}
	return null;
};

// 지정한 파일/폴더 경로가 실제로 존재하는지 확인 ------------------------------------------
export const exists = (filePath: string): boolean => {
	return fs.existsSync(filePath);
};


================================================================================================================================================================================================================================================

// types/BookmarkTypes.ts

// 북마크 메타데이터 인터페이스 -------------------------------------------------
export interface BookmarkMetadata {
	originalPath: string;
	bookmarkName: string;
	isFile: boolean;
	createdAt: number;
	lastSyncAt: number;
	originalExists: boolean;
}

// 북마크 항목 상태 ------------------------------------------------------------
export enum BookmarkStatus {
	SYNCED = "synced",
	MODIFIED = "modified",
	MISSING = "missing",
	ERROR = "error"
}

================================================================================================================================================================================================================================================

// services/BookmarkSyncService.ts

import * as vscode from "vscode";
import * as path from "path";
import { TextEncoder } from "util";
import { BookmarkMetadata, BookmarkStatus } from "../types/BookmarkTypes.js";
import { validateFileName } from "../utils/BookmarkPathUtil.js";

// -----------------------------------------------------------------------------------------
export type BookmarkSyncService = ReturnType<typeof createBookmarkSyncService>;

export const createBookmarkSyncService = (
	bookmarkPath: string,
	onSyncUpdate?: (p: string, status: BookmarkStatus) => void,
	onRefreshNeeded?: () => void
) => {
	console.debug("[SIMPLE-BOOKMARK.sync] init path =", bookmarkPath);

	const bookmarkWatchers = new Map<string, vscode.FileSystemWatcher>();
	const bookmarkedFiles = new Map<string, BookmarkMetadata>();
	const METADATA_EXT = ".bookmark.json";
	const disposables: vscode.Disposable[] = [];

	// 이벤트 기반 동기화 설정 ----------------------------------------------------------------
	// - 글로벌 워처 제거. 북마크별 워처만 등록.
	const setupEventListeners = (): void => {
		const saveListener = vscode.workspace.onDidSaveTextDocument(async (document) => {
			const filePath = document.uri.fsPath;
			if (!isBookmarkedFile(filePath)) {
				return;
			}
			console.debug("[SIMPLE-BOOKMARK.sync.save-hit]", filePath);
			await syncBookmark(filePath);
		});

		disposables.push(saveListener);
	};

	// 파일별 워처 생성 --------------------------------------------------------------------
	const createWatcherFor = (originalPath: string): void => {
		if (bookmarkWatchers.has(originalPath)) {
			return;
		}

		const pattern = new vscode.RelativePattern(path.dirname(originalPath), path.basename(originalPath));
		const watcher = vscode.workspace.createFileSystemWatcher(pattern, false, false, false);

		watcher.onDidChange(async (uri) => {
			if (uri.fsPath === originalPath) {
				console.debug("[SIMPLE-BOOKMARK.sync.change]", originalPath);
				await syncBookmark(originalPath);
			}
		});
		watcher.onDidCreate(async (uri) => {
			if (uri.fsPath === originalPath) {
				await updateBookmarkStatus(originalPath, BookmarkStatus.SYNCED);
			}
		});
		watcher.onDidDelete(async (uri) => {
			if (uri.fsPath === originalPath) {
				await updateBookmarkStatus(originalPath, BookmarkStatus.MISSING);
			}
		});

		bookmarkWatchers.set(originalPath, watcher);
	};

	const disposeWatcherFor = (originalPath: string): void => {
		const w = bookmarkWatchers.get(originalPath);
		if (w) {
			w.dispose();
			bookmarkWatchers.delete(originalPath);
		}
	};

	// 기존 북마크 로드(지연 상태 확인) ------------------------------------------------------
	const loadExistingBookmarks = async (): Promise<void> => {
		try {
			const entries = await vscode.workspace.fs.readDirectory(vscode.Uri.file(bookmarkPath));

			const metaPaths: string[] = [];
			for (const [name] of entries) {
				if (name.endsWith(METADATA_EXT)) {
					metaPaths.push(path.join(bookmarkPath, name));
				}
			}

			for (const metadataPath of metaPaths) {
				try {
					const metadata = await loadMetadata(metadataPath);
					if (metadata) {
						bookmarkedFiles.set(metadata.originalPath, metadata);
						createWatcherFor(metadata.originalPath);

						setTimeout(async () => {
							const status = await checkBookmarkStatus(metadata);
							onSyncUpdate && onSyncUpdate(metadata.originalPath, status);
							onRefreshNeeded && onRefreshNeeded();
						}, 100);
					}
				}
				catch (error) {
					console.error(`Failed to load bookmark metadata: ${metadataPath}`, error);
				}
			}

			onRefreshNeeded && onRefreshNeeded();
		}
		catch (error) {
			console.error("Failed to load existing bookmarks:", error);
		}
	};

	// 북마크 추가 (메타데이터 생성 및 저장) ------------------------------------------------
	const addBookmark = async (originalPath: string, bookmarkName?: string): Promise<void> => {
		try {
			const stat = await vscode.workspace.fs.stat(vscode.Uri.file(originalPath));

			const baseName = path.basename(originalPath);
			const finalBookmarkName = bookmarkName || baseName;
			const uniqueBookmarkName = generateUniqueBookmarkName(finalBookmarkName);

			const metadata: BookmarkMetadata = {
				originalPath: originalPath,
				bookmarkName: uniqueBookmarkName,
				isFile: stat.type === vscode.FileType.File,
				createdAt: Date.now(),
				lastSyncAt: Date.now(),
				originalExists: true
			};

			const metadataPath = path.join(bookmarkPath, `${uniqueBookmarkName}${METADATA_EXT}`);
			await saveMetadata(metadataPath, metadata);

			bookmarkedFiles.set(originalPath, metadata);
			createWatcherFor(originalPath);

			onSyncUpdate && onSyncUpdate(originalPath, BookmarkStatus.SYNCED);
			onRefreshNeeded && onRefreshNeeded();

			console.debug("[SIMPLE-BOOKMARK.sync.add]", uniqueBookmarkName);
		}
		catch (error) {
			throw new Error(`Failed to add bookmark: ${error}`);
		}
	};

	// 고유한 북마크 이름 생성 (중복 방지) -------------------------------------------------
	const generateUniqueBookmarkName = (bookmarkName: string): string => {
		let uniqueName = bookmarkName;
		let counter = 1;

		while (isBookmarkNameExists(uniqueName)) {
			const ext = path.extname(bookmarkName);
			const baseName = path.basename(bookmarkName, ext);
			uniqueName = `${baseName}_${counter}${ext}`;
			counter++;
		}

		return uniqueName;
	};

	const isBookmarkNameExists = (name: string): boolean =>
		Array.from(bookmarkedFiles.values()).some(m => m.bookmarkName === name);

	// 북마크 이름 변경 --------------------------------------------------------------------
	const renameBookmark = async (originalPath: string, newNameRaw: string): Promise<void> => {
		const metadata = bookmarkedFiles.get(originalPath);
		if (!metadata) {
			throw new Error("Bookmark not found");
		}

		const nameError = validateFileName(newNameRaw);
		if (nameError) {
			throw new Error(nameError);
		}

		// 자기 자신 이름은 중복 체크에서 제외
		const existsOther = Array.from(bookmarkedFiles.values()).some(
			m => m.originalPath !== originalPath && m.bookmarkName === newNameRaw
		);

		const finalName = existsOther ? generateUniqueBookmarkName(newNameRaw) : newNameRaw;

		const oldMetaPath = path.join(bookmarkPath, `${metadata.bookmarkName}${METADATA_EXT}`);
		const newMetaPath = path.join(bookmarkPath, `${finalName}${METADATA_EXT}`);

		metadata.bookmarkName = finalName;
		metadata.lastSyncAt = Date.now();

		// 새 파일 쓰기 → 구 파일 삭제
		await saveMetadata(newMetaPath, metadata);
		try {
			await vscode.workspace.fs.delete(vscode.Uri.file(oldMetaPath));
		}
		catch { /* noop */ }

		onRefreshNeeded && onRefreshNeeded();
		console.debug("[SIMPLE-BOOKMARK.sync.rename] ->", finalName);
	};

	// 북마크 제거 ------------------------------------------------------------------------
	const removeBookmark = async (originalPath: string): Promise<void> => {
		const metadata = bookmarkedFiles.get(originalPath);
		if (!metadata) {
			return;
		}

		try {
			const metadataPath = path.join(bookmarkPath, `${metadata.bookmarkName}${METADATA_EXT}`);
			await vscode.workspace.fs.delete(vscode.Uri.file(metadataPath));

			bookmarkedFiles.delete(originalPath);
			disposeWatcherFor(originalPath);

			onRefreshNeeded && onRefreshNeeded();
			console.debug("[SIMPLE-BOOKMARK.sync.remove]", originalPath);
		}
		catch (error) {
			console.error(`Failed to remove bookmark: ${error}`);
		}
	};

	// 특정 북마크 동기화 ----------------------------------------------------------------
	const syncBookmark = async (originalPath: string): Promise<void> => {
		const metadata = bookmarkedFiles.get(originalPath);
		if (!metadata) {
			return;
		}

		try {
			await vscode.workspace.fs.stat(vscode.Uri.file(originalPath));

			metadata.lastSyncAt = Date.now();
			metadata.originalExists = true;

			const metadataPath = path.join(bookmarkPath, `${metadata.bookmarkName}${METADATA_EXT}`);
			await saveMetadata(metadataPath, metadata);

			onSyncUpdate && onSyncUpdate(originalPath, BookmarkStatus.SYNCED);
			onRefreshNeeded && onRefreshNeeded();
		}
		catch {
			metadata.originalExists = false;

			const metadataPath = path.join(bookmarkPath, `${metadata.bookmarkName}${METADATA_EXT}`);
			try {
				await saveMetadata(metadataPath, metadata);
			}
			catch { /* noop */ }

			onSyncUpdate && onSyncUpdate(originalPath, BookmarkStatus.MISSING);
		}
	};

	// 북마크 상태 갱신 ------------------------------------------------------------------
	const updateBookmarkStatus = async (originalPath: string, status: BookmarkStatus): Promise<void> => {
		onSyncUpdate && onSyncUpdate(originalPath, status);
		onRefreshNeeded && onRefreshNeeded();
	};

	// 북마크 상태 확인 (파일 존재 여부 검사) ---------------------------------------------
	const checkBookmarkStatus = async (metadata: BookmarkMetadata): Promise<BookmarkStatus> => {
		try {
			await vscode.workspace.fs.stat(vscode.Uri.file(metadata.originalPath));
			return BookmarkStatus.SYNCED;
		}
		catch {
			return BookmarkStatus.MISSING;
		}
	};

	// 북마크 여부 확인 ----------------------------------------------------------------
	const isBookmarkedFile = (filePath: string): boolean => bookmarkedFiles.has(filePath);

	// 메타데이터 조회 -----------------------------------------------------------------
	const getAllBookmarks = (): BookmarkMetadata[] => Array.from(bookmarkedFiles.values());
	const getBookmark = (originalPath: string): BookmarkMetadata | undefined => bookmarkedFiles.get(originalPath);

	// 원본 경로 변경 시 메타데이터 갱신 -----------------------------------------------
	const updateOriginalPath = async (oldPath: string, newPath: string): Promise<void> => {
		const metadata = bookmarkedFiles.get(oldPath);
		if (!metadata) {
			return;
		}

		bookmarkedFiles.delete(oldPath);
		metadata.originalPath = newPath;

		const metadataPath = path.join(bookmarkPath, `${metadata.bookmarkName}${METADATA_EXT}`);
		await saveMetadata(metadataPath, metadata);

		bookmarkedFiles.set(newPath, metadata);

		onSyncUpdate && onSyncUpdate(newPath, BookmarkStatus.SYNCED);
		onRefreshNeeded && onRefreshNeeded();
	};

	// 메타데이터 저장 / 로드 ------------------------------------------------------
	const saveMetadata = async (metadataPath: string, metadata: BookmarkMetadata): Promise<void> => {
		const content = JSON.stringify(metadata, null, 2);
		await vscode.workspace.fs.writeFile(vscode.Uri.file(metadataPath), new TextEncoder().encode(content));
	};

	const loadMetadata = async (metadataPath: string): Promise<BookmarkMetadata | null> => {
		try {
			const content = await vscode.workspace.fs.readFile(vscode.Uri.file(metadataPath));
			return JSON.parse(content.toString()) as BookmarkMetadata;
		}
		catch {
			return null;
		}
	};

	// 리소스 정리 -------------------------------------------------------------------
	const dispose = (): void => {
		disposables.forEach(d => d.dispose());
		bookmarkWatchers.forEach(watcher => watcher.dispose());
		bookmarkWatchers.clear();
		bookmarkedFiles.clear();
	};

	// 초기화
	setupEventListeners();
	loadExistingBookmarks().catch(err => console.error(err));

	return {
		addBookmark,
		renameBookmark,
		removeBookmark,
		getAllBookmarks,
		getBookmark,
		updateOriginalPath,
		dispose
	};
};



================================================================================================================================================================================================================================================

// services/BookmarkOperationService.ts

import * as vscode from "vscode";
import * as path from "path";
import { type BookmarkSyncService } from "./BookmarkSyncService.js";
import { validateFileName } from "../utils/BookmarkPathUtil.js";

// -----------------------------------------------------------------------------------------
export type BookmarkOperationService = ReturnType<typeof createBookmarkOperationService>;

export const createBookmarkOperationService = (
	bookmarkPath: string,
	syncService?: BookmarkSyncService
) => {

	// 유틸: 폴더를 파일 목록으로 평탄화 -----------------------------------------------------
	const flattenToFiles = async (uri: vscode.Uri): Promise<string[]> => {
		const stat = await vscode.workspace.fs.stat(uri);

		if (stat.type === vscode.FileType.File) {
			return [uri.fsPath];
		}

		const out: string[] = [];
		const entries = await vscode.workspace.fs.readDirectory(uri);
		for (const [name] of entries) {
			const child = vscode.Uri.file(path.join(uri.fsPath, name));
			const childStat = await vscode.workspace.fs.stat(child);
			if (childStat.type === vscode.FileType.File) {
				out.push(child.fsPath);
			}
			else {
				const nested = await flattenToFiles(child);
				for (const p of nested) out.push(p);
			}
		}
		return out;
	};

	// 파일/폴더 재귀적 복사 ---------------------------------------------------------------------
	const copyFileOrFolder = async (source: string, target: string): Promise<void> => {
		const stat = await vscode.workspace.fs.stat(vscode.Uri.file(source));

		if (stat.type === vscode.FileType.File) {
			const content = await vscode.workspace.fs.readFile(vscode.Uri.file(source));
			await vscode.workspace.fs.writeFile(vscode.Uri.file(target), content);
		}
		else {
			try {
				await vscode.workspace.fs.stat(vscode.Uri.file(target));
				await vscode.workspace.fs.delete(vscode.Uri.file(target), { recursive: true });
			}
			catch { /* noop */ }

			await vscode.workspace.fs.createDirectory(vscode.Uri.file(target));
			const entries = await vscode.workspace.fs.readDirectory(vscode.Uri.file(source));

			for (const [name] of entries) {
				const sourcePath = path.join(source, name);
				const targetPath = path.join(target, name);
				await copyFileOrFolder(sourcePath, targetPath);
			}
		}
	};

	// 파일/폴더 붙여넣기 (강제 덮어쓰기) - 일반 폴더 대상 ---------------------------------------
	const pasteItems = async (copiedItems: vscode.Uri[], targetPath: string): Promise<void> => {
		if (copiedItems.length === 0) {
			vscode.window.showErrorMessage("No items to paste.");
			return;
		}

		let pasteCount = 0;

		for (const item of copiedItems) {
			const fileName = path.basename(item.fsPath);
			const targetFile = path.join(targetPath, fileName);
			const targetUri = vscode.Uri.file(targetFile);

			// 자기 자신에 대한 붙여넣기 방지 -----------------------------------------------------
			if (path.resolve(item.fsPath) === path.resolve(targetFile)) {
				console.debug("[SIMPLE-BOOKMARK.pasteItems]", item.fsPath);
				continue;
			}

			try {
				try {
					await vscode.workspace.fs.stat(targetUri);
					await vscode.workspace.fs.delete(targetUri, { recursive: true, useTrash: false });
				}
				catch { /* noop */ }

				await copyFileOrFolder(item.fsPath, targetFile);
				pasteCount++;
			}
			catch (error) {
				vscode.window.showErrorMessage(`Paste failed for ${fileName}: ${error}`);
			}
		}

		const message = pasteCount === 1
			? "Item pasted (overwritten)"
			: `${pasteCount} items pasted (overwritten)`;
		vscode.window.showInformationMessage(message);
		console.debug("[SIMPLE-BOOKMARK.pasteItems.count]", pasteCount);
	};

	// 루트 붙여넣기: 파일명 매칭 → 각 북마크의 실제 경로에 덮어쓰기 ----------------------------
	const pasteItemsToRoot = async (copiedItems: vscode.Uri[], nameToOriginalPath: Map<string, string>): Promise<void> => {
		if (copiedItems.length === 0) {
			vscode.window.showErrorMessage("No items to paste.");
			return;
		}

		// 폴더가 포함되어도 파일 단위로 매칭되도록 평탄화 --------------------------------------
		const srcFilesSet = new Set<string>();
		for (const uri of copiedItems) {
			const files = await flattenToFiles(uri);
			for (const f of files) srcFilesSet.add(f);
		}
		const srcFiles = Array.from(srcFilesSet.values());

		let overwriteCount = 0;
		const skipped: string[] = [];

		for (const src of srcFiles) {
			const fileName = path.basename(src);
			const realTarget = nameToOriginalPath.get(fileName);

			if (!realTarget) {
				skipped.push(fileName);
				continue;
			}

			if (path.resolve(src) === path.resolve(realTarget)) {
				console.debug("[SIMPLE-BOOKMARK.pasteItemsToRoot]", src);
				continue;
			}

			try {
				try {
					await vscode.workspace.fs.stat(vscode.Uri.file(realTarget));
					await vscode.workspace.fs.delete(vscode.Uri.file(realTarget), { recursive: true, useTrash: false });
				}
				catch { /* noop */ }

				await copyFileOrFolder(src, realTarget);
				overwriteCount++;
			}
			catch (error) {
				vscode.window.showErrorMessage(`Root overwrite failed for ${fileName}: ${error}`);
			}
		}

		if (overwriteCount > 0) {
			const msg = overwriteCount === 1
				? "1 file overwritten to original targets"
				: `${overwriteCount} files overwritten to original targets`;
			vscode.window.showInformationMessage(msg);
		}
		if (skipped.length > 0) {
			console.debug("[SIMPLE-BOOKMARK skipped(non-matching names)]:", skipped);
		}
	};

	// 실제 원본 파일/폴더 삭제 -------------------------------------------------------------
	const deleteOriginalFiles = async (items: vscode.Uri[]): Promise<void> => {
		let deleteCount = 0;

		for (const item of items) {
			try {
				await vscode.workspace.fs.delete(item, { recursive: true });
				deleteCount++;
				console.debug("[SIMPLE-BOOKMARK.deleteOriginalFiles]", item.fsPath);
			}
			catch (error) {
				console.error(`Failed to delete original file: ${item.fsPath}`, error);
			}
		}

		const successMessage = deleteCount === 1
			? "Original file deleted"
			: `${deleteCount} original files deleted`;
		vscode.window.showInformationMessage(successMessage);
	};

	// 실제 위치에 새 폴더 생성 -------------------------------------------------------------
	const createFolder = async (parentPath: string, folderName: string): Promise<void> => {
		const error = validateFileName(folderName);
		if (error) {
			vscode.window.showErrorMessage(error);
			return;
		}

		const folderPath = path.join(parentPath, folderName);

		try {
			await vscode.workspace.fs.stat(vscode.Uri.file(folderPath));
			await vscode.workspace.fs.delete(vscode.Uri.file(folderPath), { recursive: true });
		}
		catch { /* noop */ }

		await vscode.workspace.fs.createDirectory(vscode.Uri.file(folderPath));

		vscode.window.showInformationMessage(`Folder created in original location: ${folderName}`);
		console.debug("[SIMPLE-BOOKMARK.createFolder]", folderPath);
	};

	// 실제 위치에 새 파일 생성 ---------------------------------------------------------------
	const createFile = async (parentPath: string, fileName: string): Promise<void> => {
		const error = validateFileName(fileName);
		if (error) {
			vscode.window.showErrorMessage(error);
			return;
		}

		const filePath = path.join(parentPath, fileName);

		await vscode.workspace.fs.writeFile(vscode.Uri.file(filePath), new Uint8Array(0));

		vscode.window.showInformationMessage(`File created in original location: ${fileName}`);
		console.debug("[SIMPLE-BOOKMARK.createFile]", filePath);

		try {
			const document = await vscode.workspace.openTextDocument(vscode.Uri.file(filePath));
			await vscode.window.showTextDocument(document);
		}
		catch (error) {
			console.error(`Failed to open created file: ${error}`);
		}
	};

	// 파일 변경 감지 (존재 여부 확인) ----------------------------------------------------
	const checkForChanges = async (filePaths: string[]): Promise<string[]> => {
		const changedFiles: string[] = [];

		for (const filePath of filePaths) {
			try {
				await vscode.workspace.fs.stat(vscode.Uri.file(filePath));
			}
			catch {
				changedFiles.push(filePath);
			}
		}

		return changedFiles;
	};

	// 북마크 폴더 경로 업데이트 -----------------------------------------------------------
	const updateBookmarkPath = (newPath: string): void => {
		bookmarkPath = newPath;
	};

	return {
		pasteItems,
		pasteItemsToRoot,
		deleteOriginalFiles,
		createFolder,
		createFile,
		checkForChanges,
		updateBookmarkPath
	};
};



================================================================================================================================================================================================================================================

// providers/BookmarkProvider.ts

import * as vscode from "vscode";
import * as path from "path";
import { createBookmarkSystemItem, type BookmarkSystemItem } from "../models/BookmarkSystemItem.js";
import { createBookmarkOperationService, type BookmarkOperationService } from "../services/BookmarkOperationService.js";
import { createBookmarkSyncService, type BookmarkSyncService } from "../services/BookmarkSyncService.js";
import { getBookmarkPath } from "../utils/BookmarkPathUtil.js";
import { BookmarkStatus } from "../types/BookmarkTypes.js";

// -------------------------------------------------------------------------------
export type BookmarkProvider = ReturnType<typeof createBookmarkProvider>;

export const createBookmarkProvider = (workspaceRoot: string | undefined) => {
	const _onDidChangeTreeData = new vscode.EventEmitter<BookmarkSystemItem | undefined | null | void>();
	const onDidChangeTreeData = _onDidChangeTreeData.event;

	let bookmarkPath: string | undefined;
	let copiedBookmarks: vscode.Uri[] = [];
	let fileOperationService: BookmarkOperationService | undefined;
	let syncService: BookmarkSyncService | undefined;
	const bookmarkStatusMap: Map<string, BookmarkStatus> = new Map();

	// refresh 디바운스 -------------------------------------------------------------
	let refreshTimer: NodeJS.Timeout | null = null;
	const refreshDebounceMs = 150;

	setTimeout(() => initializeBookmarkFolder().catch(err => console.error(err)), 0);

	// .bookmark 폴더 초기화 ---------------------------------------------------------
	const initializeBookmarkFolder = async (): Promise<void> => {
		if (!workspaceRoot) {
			return;
		}

		bookmarkPath = getBookmarkPath(workspaceRoot);

		try {
			await vscode.workspace.fs.stat(vscode.Uri.file(bookmarkPath));
		}
		catch {
			try {
				await vscode.workspace.fs.createDirectory(vscode.Uri.file(bookmarkPath));
				vscode.window.showInformationMessage(`BOOKMARK folder created: ${bookmarkPath}`);
			}
			catch (error) {
				vscode.window.showErrorMessage(`Failed to create BOOKMARK folder: ${error}`);
				return;
			}
		}

		if (bookmarkPath) {
			syncService = createBookmarkSyncService(
				bookmarkPath,
				(p: string, status: BookmarkStatus) => {
					bookmarkStatusMap.set(p, status);
				},
				() => refresh()
			);

			fileOperationService = createBookmarkOperationService(
				bookmarkPath,
				syncService
			);
		}
	};

	// 트리 갱신(디바운스) --------------------------------------------------------------
	const refresh = (): void => {
		if (refreshTimer) clearTimeout(refreshTimer);
		refreshTimer = setTimeout(() => {
			_onDidChangeTreeData.fire();
		}, refreshDebounceMs);
	};

	// 트리 항목 반환 ------------------------------------------------------------------
	const getTreeItem = (element: BookmarkSystemItem): vscode.TreeItem => element;

	// 자식 항목 가져오기 --------------------------------------------------------------
	// - 최상위: 실제 루트 북마크 목록만 반환(가짜 아이템 없음)
	const getChildren = async (element?: BookmarkSystemItem): Promise<BookmarkSystemItem[]> => {
		if (!bookmarkPath || !syncService) {
			return [];
		}

		if (!element) {
			return getRootBookmarks();
		}

		if (!element.bookmarkMetadata.isFile && element.isOriginalAvailable) {
			return getFolderContents(element.originalPath);
		}

		return [];
	};

	// 루트 레벨 북마크 가져오기 ------------------------------------------------------
	const getRootBookmarks = async (): Promise<BookmarkSystemItem[]> => {
		if (!syncService) {
			return [];
		}

		const bookmarks = syncService.getAllBookmarks();
		const items: BookmarkSystemItem[] = [];

		for (const metadata of bookmarks) {
			const status = bookmarkStatusMap.get(metadata.originalPath) || BookmarkStatus.SYNCED;
			items.push(createBookmarkSystemItem(metadata, status));
		}

		return items.sort((a, b) => {
			const aIsDir = !a.bookmarkMetadata.isFile;
			const bIsDir = !b.bookmarkMetadata.isFile;

			if (aIsDir && !bIsDir) return -1;
			if (!aIsDir && bIsDir) return 1;
			return a.bookmarkMetadata.bookmarkName.localeCompare(b.bookmarkMetadata.bookmarkName);
		});
	};

	// 실제 폴더의 하위 항목 가져오기 ---------------------------------------------------
	const getFolderContents = async (folderPath: string): Promise<BookmarkSystemItem[]> => {
		try {
			const entries = await vscode.workspace.fs.readDirectory(vscode.Uri.file(folderPath));
			const items: BookmarkSystemItem[] = [];

			const sortedEntries = entries.sort((a, b) => {
				if (a[1] === vscode.FileType.Directory && b[1] !== vscode.FileType.Directory) return -1;
				if (a[1] !== vscode.FileType.Directory && b[1] === vscode.FileType.Directory) return 1;
				return a[0].localeCompare(b[0]);
			});

			for (const [name, type] of sortedEntries) {
				const itemPath = path.join(folderPath, name);

				const virtualMetadata = {
					originalPath: itemPath,
					bookmarkName: name,
					isFile: type === vscode.FileType.File,
					createdAt: Date.now(),
					lastSyncAt: Date.now(),
					originalExists: true
				};

				items.push(createBookmarkSystemItem(virtualMetadata, BookmarkStatus.SYNCED));
			}

			return items;
		}
		catch (error) {
			console.error(`Error reading folder contents: ${folderPath}`, error);
			return [];
		}
	};

	// 북마크 추가 --------------------------------------------------------------------
	const addBookmark = async (sourcePath: string, bookmarkName?: string): Promise<void> => {
		if (!syncService) {
			vscode.window.showErrorMessage("Bookmark sync service not initialized.");
			return;
		}

		try {
			const finalBookmarkName = bookmarkName || path.basename(sourcePath);

			// 기존 동명 북마크 제거 후 생성
			const existing = syncService.getAllBookmarks().filter(b => b.bookmarkName === finalBookmarkName);
			for (const meta of existing) {
				await syncService.removeBookmark(meta.originalPath);
			}

			await syncService.addBookmark(sourcePath, finalBookmarkName);
			vscode.window.showInformationMessage(`Bookmark overwritten: ${finalBookmarkName}`);
			console.debug("[SIMPLE-BOOKMARK.provider.add]", sourcePath, "->", finalBookmarkName);
		}
		catch (error) {
			vscode.window.showErrorMessage(`Failed to add bookmark: ${error}`);
		}
	};

	// 북마크 제거 (원본 파일은 유지) -------------------------------------------------
	const removeBookmark = async (originalPath: string): Promise<void> => {
		if (!syncService) {
			vscode.window.showErrorMessage("Bookmark sync service not initialized.");
			return;
		}

		try {
			await syncService.removeBookmark(originalPath);
			console.debug("[SIMPLE-BOOKMARK.provider.remove]", originalPath);
		}
		catch (error) {
			vscode.window.showErrorMessage(`Failed to remove bookmark: ${error}`);
		}
	};

	// 북마크 이름 변경 ----------------------------------------------------------------
	const renameBookmark = async (originalPath: string, newName: string): Promise<void> => {
		if (!syncService) {
			vscode.window.showErrorMessage("Bookmark sync service not initialized.");
			return;
		}

		try {
			await syncService.renameBookmark(originalPath, newName);
			console.debug("[SIMPLE-BOOKMARK.provider.rename]", originalPath, "->", newName);
		}
		catch (error) {
			vscode.window.showErrorMessage(`Failed to rename bookmark: ${error}`);
		}
	};

	// 복사 / 붙여넣기 ---------------------------------------------------------------
	const copyBookmarks = (items: BookmarkSystemItem[]): void => {
		// 스냅샷 + 중복 제거
		const dedup = new Map<string, vscode.Uri>();
		for (const it of items) {
			if (!dedup.has(it.originalPath)) {
				dedup.set(it.originalPath, vscode.Uri.file(it.originalPath));
			}
		}
		copiedBookmarks = Array.from(dedup.values());

		const message = copiedBookmarks.length === 1
			? `Copied: ${path.basename(copiedBookmarks[0].fsPath)}`
			: `Copied ${copiedBookmarks.length} items`;
		vscode.window.showInformationMessage(message);
		console.debug("[SIMPLE-BOOKMARK.provider.copy.len]", copiedBookmarks.length);
	};

	const pasteItems = async (targetPath: string): Promise<void> => {
		if (!fileOperationService) {
			vscode.window.showErrorMessage("File operation service not initialized.");
			return;
		}
		await fileOperationService.pasteItems(copiedBookmarks, targetPath);
	};

	// 루트 붙여넣기: 파일명 매칭 → 각 북마크의 실제 경로에 덮어쓰기 -------------------
	const pasteItemsToRoot = async (): Promise<void> => {
		if (!fileOperationService || !syncService) {
			vscode.window.showErrorMessage("File operation service not initialized.");
			return;
		}
		const all = syncService.getAllBookmarks();

		const nameToOriginalPath = new Map<string, string>();
		for (const m of all) {
			m.isFile && nameToOriginalPath.set(m.bookmarkName, m.originalPath);
		}

		if (nameToOriginalPath.size === 0) {
			vscode.window.showWarningMessage("No root file bookmarks to overwrite.");
			return;
		}

		await fileOperationService.pasteItemsToRoot(copiedBookmarks, nameToOriginalPath);
	};

	// 파일/폴더 생성 ------------------------------------------------------------------
	const createFolder = async (parentPath: string, folderName: string): Promise<void> => {
		if (!fileOperationService) {
			vscode.window.showErrorMessage("File operation service not initialized.");
			return;
		}
		await fileOperationService.createFolder(parentPath, folderName);
	};

	const createFile = async (parentPath: string, fileName: string): Promise<void> => {
		if (!fileOperationService) {
			vscode.window.showErrorMessage("File operation service not initialized.");
			return;
		}
		await fileOperationService.createFile(parentPath, fileName);
	};

	// Getter 및 상태 확인 --------------------------------------------------------------
	const rootPath = (): string | undefined => bookmarkPath;

	const hasCopiedItems = (): boolean => copiedBookmarks.length > 0;

	const getBookmarkStatus = (originalPath: string): BookmarkStatus =>
		bookmarkStatusMap.get(originalPath) || BookmarkStatus.SYNCED;

	const isRootBookmark = (originalPath: string): boolean =>
		!!syncService?.getBookmark(originalPath);

	// 리소스 정리 --------------------------------------------------------------------
	const dispose = (): void => {
		syncService && syncService.dispose();
	};

	return {
		// TreeDataProvider 인터페이스
		onDidChangeTreeData,
		getTreeItem,
		getChildren,

		// control
		refresh,

		// ops
		addBookmark,
		removeBookmark,
		renameBookmark,
		copyBookmarks,
		pasteItems,
		pasteItemsToRoot,
		createFolder,
		createFile,

		// state
		get rootPath() { return rootPath(); },
		hasCopiedItems,
		getBookmarkStatus,
		isRootBookmark,

		// lifecycle
		dispose
	};
};



================================================================================================================================================================================================================================================

// models/BookmarkSystemItem.ts

import * as vscode from "vscode";
import { BookmarkMetadata, BookmarkStatus } from "../types/BookmarkTypes.js";

// -----------------------------------------------------------------------------------------
export type BookmarkSystemItem = vscode.TreeItem & {
	originalPath: string;
	bookmarkMetadata: BookmarkMetadata;
	status: BookmarkStatus;
	isOriginalAvailable: boolean;
	updateStatus: (newStatus: BookmarkStatus) => void;
};

// 트리 항목 UI 설정 ------------------------------------------------------------------------
const setupDisplay = (item: BookmarkSystemItem): void => {
	const baseName = item.bookmarkMetadata.bookmarkName;

	switch (item.status) {
		case BookmarkStatus.SYNCED:
			item.label = baseName;
			item.description = "";
			item.iconPath = item.bookmarkMetadata.isFile
				? new vscode.ThemeIcon("file", new vscode.ThemeColor("foreground"))
				: new vscode.ThemeIcon("folder", new vscode.ThemeColor("foreground"));
			break;
		case BookmarkStatus.MISSING:
			item.label = baseName;
			item.description = "(missing)";
			item.iconPath = item.bookmarkMetadata.isFile
				? new vscode.ThemeIcon("file", new vscode.ThemeColor("errorForeground"))
				: new vscode.ThemeIcon("folder", new vscode.ThemeColor("errorForeground"));
			break;
		case BookmarkStatus.MODIFIED:
			item.label = baseName;
			item.description = "(modified)";
			item.iconPath = item.bookmarkMetadata.isFile
				? new vscode.ThemeIcon("file", new vscode.ThemeColor("gitModified"))
				: new vscode.ThemeIcon("folder", new vscode.ThemeColor("gitModified"));
			break;
		case BookmarkStatus.ERROR:
			item.label = baseName;
			item.description = "(error)";
			item.iconPath = item.bookmarkMetadata.isFile
				? new vscode.ThemeIcon("file", new vscode.ThemeColor("errorForeground"))
				: new vscode.ThemeIcon("folder", new vscode.ThemeColor("errorForeground"));
			break;
	}

	item.tooltip = new vscode.MarkdownString(`**${item.bookmarkMetadata.bookmarkName}**\n\n**Original Path:** ${item.originalPath}`);
	item.command = (
		item.bookmarkMetadata.isFile && item.status === BookmarkStatus.SYNCED
			? {
				command: "vscode.open",
				title: "Open Original File",
				arguments: [vscode.Uri.file(item.originalPath)]
			}
			: undefined
	);
};

// 상태 업데이트 (UI 재설정 포함) ---------------------------------------------------------
const updateStatus = function (this: BookmarkSystemItem, newStatus: BookmarkStatus): void {
	if (this.status !== newStatus) {
		(this as any).status = newStatus;
		setupDisplay(this);
	}
};

// 원본 파일 사용 가능 여부 확인 -----------------------------------------------------------
const computeIsOriginalAvailable = (status: BookmarkStatus): boolean =>
	status === BookmarkStatus.SYNCED || status === BookmarkStatus.MODIFIED;

export const createBookmarkSystemItem = (
	metadata: BookmarkMetadata,
	status: BookmarkStatus = BookmarkStatus.SYNCED,
	options?: { contextValueOverride?: string; }
): BookmarkSystemItem => {
	const collapsibleState = metadata.isFile
		? vscode.TreeItemCollapsibleState.None
		: vscode.TreeItemCollapsibleState.Collapsed;

	const base = new vscode.TreeItem(metadata.bookmarkName, collapsibleState) as BookmarkSystemItem;

	base.originalPath = metadata.originalPath;
	base.bookmarkMetadata = metadata;
	base.status = status;

	base.resourceUri = vscode.Uri.file(metadata.originalPath);
	base.contextValue = options?.contextValueOverride
		? options.contextValueOverride
		: (metadata.isFile ? "bookmarkFile" : "bookmarkFolder");

	(base as any).updateStatus = updateStatus.bind(base);
	Object.defineProperty(base, "isOriginalAvailable", {
		get() { return computeIsOriginalAvailable(base.status); }
	});

	setupDisplay(base);
	return base;
};



================================================================================================================================================================================================================================================

// commands/BookmarkCommand.ts

import * as vscode from "vscode";
import * as path from "path";
import type { BookmarkProvider } from "../providers/BookmarkProvider.js";
import type { BookmarkSystemItem } from "../models/BookmarkSystemItem.js";
import { validateFileName } from "../utils/BookmarkPathUtil.js";

// -----------------------------------------------------------------------------------------
export type BookmarkCommand = ReturnType<typeof createBookmarkCommand>;

export const createBookmarkCommand = (
	provider: BookmarkProvider,
	context: vscode.ExtensionContext
) => {
	let selectedBookmarks: BookmarkSystemItem[] = [];

	// 선택된 아이템 업데이트 -----------------------------------------------------------------
	const updateSelectedBookmark = (items: BookmarkSystemItem[]): void => {
		selectedBookmarks = items;
	};

	// 모든 명령어 등록 -----------------------------------------------------------------------
	const registerCommands = (): vscode.Disposable[] => ([
		registerRefreshCommand(),
		registerAddBookmarkCommand(),
		registerRemoveBookmarkCommand(),
		registerRenameBookmarkCommand(),
		registerCopyBookmarkCommand(),
		registerPasteBookmarkCommand(),
		registerPasteToRootBookmarkCommand(),
		registerDeleteAllBookmarkCommand(),
		registerCreateFolderCommand(),
		registerCreateFileCommand()
	]);

	// 북마크 새로고침 -------------------------------------------------------------------------
	const registerRefreshCommand = (): vscode.Disposable =>
	vscode.commands.registerCommand("SIMPLE-BOOKMARK.refreshentry", () => {
		console.debug("[SIMPLE-BOOKMARK.cmd.refresh]");
		provider.refresh();
	});

	// 북마크 추가 (Explorer 선택 기반) --------------------------------------------------------
	const registerAddBookmarkCommand = (): vscode.Disposable =>
	vscode.commands.registerCommand("SIMPLE-BOOKMARK.addbookmark", async (uri?: vscode.Uri) => {
		if (!uri) {
			await vscode.commands.executeCommand("copyFilePath");
			const copied = await vscode.env.clipboard.readText();
			uri = copied ? vscode.Uri.file(copied.split(/\r?\n/)[0]) : undefined;
		}

		if (!uri) {
			vscode.window.showErrorMessage("No file or folder selected in Explorer.");
			return;
		}

		const stat = await vscode.workspace.fs.stat(uri);
		const bookmarkName = path.basename(uri.fsPath);

		if (stat.type === vscode.FileType.Directory || stat.type === vscode.FileType.File) {
			await provider.addBookmark(uri.fsPath, bookmarkName);
			provider.refresh();
		}
		else {
			vscode.window.showErrorMessage("Only files or folders can be added.");
		}
	});


	// 북마크 제거 (루트만) --------------------------------------------------------------------
	const registerRemoveBookmarkCommand = (): vscode.Disposable =>
	vscode.commands.registerCommand("SIMPLE-BOOKMARK.removebookmark", async (item?: BookmarkSystemItem) => {
		let itemsToRemove: string[];

		if (item) {
			itemsToRemove = [item.originalPath];
		}
		else if (selectedBookmarks.length > 0) {
			itemsToRemove = selectedBookmarks
				.filter(i => provider.isRootBookmark(i.originalPath))
				.map(i => i.originalPath);
		}
		else {
			vscode.window.showErrorMessage("No bookmarks selected to remove.");
			return;
		}

		if (itemsToRemove.length === 0) {
			vscode.window.showWarningMessage("Only root-level bookmarks can be removed.");
			return;
		}

		for (const originalPath of itemsToRemove) {
			await provider.removeBookmark(originalPath);
		}
		provider.refresh();

		const msg = itemsToRemove.length === 1 ? "Bookmark removed" : `${itemsToRemove.length} bookmarks removed`;
		vscode.window.showInformationMessage(msg);
	});

	// 북마크 이름 변경 -------------------------------------------------------------------------
	const registerRenameBookmarkCommand = (): vscode.Disposable => vscode.commands.registerCommand("SIMPLE-BOOKMARK.renamebookmark", async (item?: BookmarkSystemItem) => {
		let target: BookmarkSystemItem | undefined = item || (selectedBookmarks.length > 0 ? selectedBookmarks[0] : undefined);

		if (!target) {
			vscode.window.showErrorMessage("No bookmark selected to rename.");
			return;
		}

		// 루트 북마크만 허용
		if (!provider.isRootBookmark(target.originalPath)) {
			vscode.window.showWarningMessage("Only root-level bookmarks can be renamed.");
			return;
		}

		const currentName = target.bookmarkMetadata.bookmarkName;

		const newName = await vscode.window.showInputBox({
			prompt: "Enter new bookmark name",
			value: currentName,
			validateInput: (v: string) => validateFileName(v)
		});

		if (!newName) return;

		await provider.renameBookmark(target.originalPath, newName.trim());
		provider.refresh();
		vscode.window.showInformationMessage(`Bookmark renamed: ${currentName} → ${newName.trim()}`);
	});

	// 복사 ----------------------------------------------------------------------------------
	const registerCopyBookmarkCommand = (): vscode.Disposable =>
		vscode.commands.registerCommand("SIMPLE-BOOKMARK.copybookmark", (item?: BookmarkSystemItem, selected?: BookmarkSystemItem[]) => {
			let targets: BookmarkSystemItem[] = [];

			if (Array.isArray(selected) && selected.length > 0) {
				targets = selected;
			}
			else if (selectedBookmarks.length > 0) {
				targets = selectedBookmarks;
			}
			else if (item) {
				targets = [item];
			}
			else {
				vscode.window.showErrorMessage("No items selected to copy.");
				return;
			}

			// 중복 제거 ----------------------------------------------------------------------
			const dedupMap = new Map<string, BookmarkSystemItem>();
			for (const t of targets) {
				if (!dedupMap.has(t.originalPath)) dedupMap.set(t.originalPath, t);
			}
			targets = Array.from(dedupMap.values());

			const available = targets.filter((t) => t.isOriginalAvailable);
			if (available.length === 0) {
				vscode.window.showWarningMessage("No available original files to copy.");
				return;
			}

			updateSelectedBookmark(available);
			provider.copyBookmarks(available);
			provider.refresh();
		});

	// 붙여넣기 -----------------------------------------------------------------------------
	// - 아이템 지정 없음: 루트 매칭 덮어쓰기
	// - 아이템 컨텍스트: 해당 위치로 붙여넣기
	const registerPasteBookmarkCommand = (): vscode.Disposable =>
	vscode.commands.registerCommand("SIMPLE-BOOKMARK.pastebookmark", async (item?: BookmarkSystemItem) => {
		if (!provider.hasCopiedItems()) {
			vscode.window.showErrorMessage("No items to paste.");
			return;
		}

		if (!item && selectedBookmarks.length === 0) {
			await provider.pasteItemsToRoot();
			provider.refresh();
			return;
		}

		let targetPath: string | undefined;

		if (item) {
			updateSelectedBookmark([item]);
			targetPath = (!item.bookmarkMetadata.isFile && item.isOriginalAvailable)
				? item.originalPath
				: path.dirname(item.originalPath);
		}
		else if (selectedBookmarks.length > 0) {
			const folder = selectedBookmarks.find(s => !s.bookmarkMetadata.isFile && s.isOriginalAvailable);
			targetPath = folder ? folder.originalPath : path.dirname(selectedBookmarks[0].originalPath);
		}
		else {
			targetPath = provider.rootPath;
		}

		if (targetPath) {
			console.debug("[SIMPLE-BOOKMARK.pastebookmark]", targetPath);
			await provider.pasteItems(targetPath);
			provider.refresh();
		}
		else {
			vscode.window.showWarningMessage("Select a valid target folder to paste into.");
		}
	});

	// 붙여넣기(루트 전용) -----------------------------------------------------------------
	const registerPasteToRootBookmarkCommand = (): vscode.Disposable =>
	vscode.commands.registerCommand("SIMPLE-BOOKMARK.pasterootbookmark", async () => {
		if (!provider.hasCopiedItems()) {
			vscode.window.showErrorMessage("No items to paste.");
			return;
		}
		await provider.pasteItemsToRoot();
		provider.refresh();
	});

	// 모든 북마크 삭제 --------------------------------------------------------------------
	const registerDeleteAllBookmarkCommand = (): vscode.Disposable =>
	vscode.commands.registerCommand("SIMPLE-BOOKMARK.removeallbookmark", async () => {
		const allItems = await provider.getChildren();

		if (allItems && allItems.length > 0) {
			for (const item of allItems) {
				await provider.removeBookmark(item.originalPath);
			}
			provider.refresh();
			vscode.window.showInformationMessage(`All ${allItems.length} bookmarks removed successfully`);
		}
		else {
			vscode.window.showInformationMessage("No bookmarks to remove.");
		}
	});

	// 폴더 생성 --------------------------------------------------------------------------
	const registerCreateFolderCommand = (): vscode.Disposable =>
	vscode.commands.registerCommand("SIMPLE-BOOKMARK.createfolder", async (item?: BookmarkSystemItem) => {
		const folderName = await vscode.window.showInputBox({
			prompt: "Enter folder name (will be created in original location)",
			validateInput: validateFileName
		});

		if (!folderName) return;

		let parentPath: string | undefined;

		if (item && !item.bookmarkMetadata.isFile && item.isOriginalAvailable) {
			parentPath = item.originalPath;
		}
		else {
			const folderUri = await vscode.window.showOpenDialog({
				canSelectFiles: false,
				canSelectFolders: true,
				canSelectMany: false,
				openLabel: "Select Parent Folder"
			});

			parentPath = folderUri && folderUri.length > 0 ? folderUri[0].fsPath : undefined;
		}

		if (parentPath) {
			await provider.createFolder(parentPath, folderName.trim());
			provider.refresh();
		}
		else {
			vscode.window.showWarningMessage("Please select a valid parent folder.");
		}
	});

	// 파일 생성 --------------------------------------------------------------------------
	const registerCreateFileCommand = (): vscode.Disposable =>
	vscode.commands.registerCommand("SIMPLE-BOOKMARK.createfile", async (item?: BookmarkSystemItem) => {
		const fileName = await vscode.window.showInputBox({
			prompt: "Enter file name (will be created in original location)",
			validateInput: validateFileName
		});

		if (!fileName) return;

		let parentPath: string | undefined;

		if (item && !item.bookmarkMetadata.isFile && item.isOriginalAvailable) {
			parentPath = item.originalPath;
		}
		else {
			const folderUri = await vscode.window.showOpenDialog({
				canSelectFiles: false,
				canSelectFolders: true,
				canSelectMany: false,
				openLabel: "Select Parent Folder"
			});

			parentPath = folderUri && folderUri.length > 0 ? folderUri[0].fsPath : undefined;
		}

		if (parentPath) {
			await provider.createFile(parentPath, fileName.trim());
			provider.refresh();
		}
		else {
			vscode.window.showWarningMessage("Please select a valid parent folder.");
		}
	});

	return {
		updateSelectedBookmark,
		registerCommands
	};
};



================================================================================================================================================================================================================================================

	{
		"name": "SIMPLE-BOOKMARK",
		"displayName": "SIMPLE-BOOKMARK",
		"publisher": "JUNGHO",
		"icon": "logo_image.png",
		"license": "Apache-2.0",
		"type": "module",
		"version": "2.1.0",
		"description": "Real-time synchronized bookmarks for VSCode with .bookmark folder-based organization",
		"main": "./out/extension.js",
		"repository": {
			"type": "git",
			"url": "https://github.com/JUNGHO-GIT/SIMPLE-BOOKMARK.git"
		},
		"engines": {
			"vscode": "^1.104.0",
			"node": ">=18.0.0",
			"npm": ">=10.0.0"
		},
		"categories": [
			"Other"
		],
		"keywords": [
			"explorer",
			"bookmark",
			"sync",
			"realtime",
			"file",
			"manager",
			"watcher"
		],
		"activationEvents": [
			"onView:SIMPLE-BOOKMARK",
			"onCommand:SIMPLE-BOOKMARK.additem",
			"onCommand:SIMPLE-BOOKMARK.refreshentry",
			"onCommand:SIMPLE-BOOKMARK.copyitem",
			"onCommand:SIMPLE-BOOKMARK.pasteitem",
			"onCommand:SIMPLE-BOOKMARK.pasteroot",
			"onCommand:SIMPLE-BOOKMARK.removeitem",
			"onCommand:SIMPLE-BOOKMARK.removeallitems",
			"onCommand:SIMPLE-BOOKMARK.createfolder",
			"onCommand:SIMPLE-BOOKMARK.createfile",
			"onCommand:SIMPLE-BOOKMARK.renamebookmark"
		],
		"contributes": {
			"views": {
				"explorer": [
					{
						"id": "SIMPLE-BOOKMARK",
						"name": "BOOKMARK",
						"icon": "$(bookmark)",
						"when": "workspaceFolderCount > 0"
					}
				]
			},
			"commands": [
				{
					"command": "SIMPLE-BOOKMARK.additem",
					"title": "Add to Bookmarks",
					"category": "SIMPLE-BOOKMARK"
				},
				{
					"command": "SIMPLE-BOOKMARK.refreshentry",
					"title": "Refresh Bookmarks",
					"category": "SIMPLE-BOOKMARK",
					"icon": "$(refresh)"
				},
				{
					"command": "SIMPLE-BOOKMARK.copyitem",
					"title": "Copy",
					"category": "SIMPLE-BOOKMARK",
					"icon": "$(copy)"
				},
				{
					"command": "SIMPLE-BOOKMARK.pasteitem",
					"title": "Paste",
					"category": "SIMPLE-BOOKMARK",
					"icon": "$(replace-all)"
				},
				{
					"command": "SIMPLE-BOOKMARK.pasteroot",
					"title": "Paste to Root",
					"category": "SIMPLE-BOOKMARK",
					"icon": "$(replace-all)"
				},
				{
					"command": "SIMPLE-BOOKMARK.createfolder",
					"title": "Create Folder",
					"category": "SIMPLE-BOOKMARK",
					"icon": "$(new-folder)"
				},
				{
					"command": "SIMPLE-BOOKMARK.createfile",
					"title": "Create File",
					"category": "SIMPLE-BOOKMARK",
					"icon": "$(new-file)"
				},
				{
					"command": "SIMPLE-BOOKMARK.removeitem",
					"title": "Remove",
					"category": "SIMPLE-BOOKMARK",
					"icon": "$(remove-close)"
				},
				{
					"command": "SIMPLE-BOOKMARK.removeallitems",
					"title": "Remove All",
					"category": "SIMPLE-BOOKMARK",
					"icon": "$(terminal-kill)"
				},
				{
					"command": "SIMPLE-BOOKMARK.renamebookmark",
					"title": "Rename",
					"category": "SIMPLE-BOOKMARK",
					"icon": "$(edit)"
				}
			],
			"keybindings": [
				{
					"key": "shift+alt+a",
					"command": "SIMPLE-BOOKMARK.additem",
					"when": "focusedView == SIMPLE-BOOKMARK"
				},
				{
					"key": "shift+alt+a",
					"command": "SIMPLE-BOOKMARK.additem",
					"when": "explorerViewletVisible && filesExplorerFocus"
				},
				{
					"key": "ctrl+c",
					"command": "SIMPLE-BOOKMARK.copyitem",
					"when": "focusedView == SIMPLE-BOOKMARK"
				},
				{
					"key": "ctrl+v",
					"command": "SIMPLE-BOOKMARK.pasteitem",
					"when": "focusedView == SIMPLE-BOOKMARK"
				},
				{
					"key": "ctrl+d",
					"command": "SIMPLE-BOOKMARK.removeitem",
					"when": "focusedView == SIMPLE-BOOKMARK"
				},
				{
					"key": "f2",
					"command": "SIMPLE-BOOKMARK.renamebookmark",
					"when": "focusedView == SIMPLE-BOOKMARK"
				}
			],
			"menus": {
				"view/title": [
					{
						"command": "SIMPLE-BOOKMARK.refreshentry",
						"when": "view == SIMPLE-BOOKMARK",
						"group": "navigation"
					},
					{
						"command": "SIMPLE-BOOKMARK.copyitem",
						"when": "view == SIMPLE-BOOKMARK",
						"group": "navigation"
					},
					{
						"command": "SIMPLE-BOOKMARK.pasteroot",
						"when": "view == SIMPLE-BOOKMARK",
						"group": "navigation"
					},
					{
						"command": "SIMPLE-BOOKMARK.removeallitems",
						"when": "view == SIMPLE-BOOKMARK",
						"group": "navigation"
					}
				],
				"view/item/context": [
					{
						"command": "SIMPLE-BOOKMARK.copyitem",
						"when": "view == SIMPLE-BOOKMARK",
						"group": "1_clipboard@1"
					},
					{
						"command": "SIMPLE-BOOKMARK.pasteitem",
						"when": "view == SIMPLE-BOOKMARK && viewItem == bookmarkFolder",
						"group": "1_clipboard@2"
					},
					{
						"command": "SIMPLE-BOOKMARK.pasteitem",
						"when": "view == SIMPLE-BOOKMARK && viewItem == bookmarkFile",
						"group": "1_clipboard@3"
					},
					{
						"command": "SIMPLE-BOOKMARK.renamebookmark",
						"when": "view == SIMPLE-BOOKMARK && (viewItem == bookmarkFile || viewItem == bookmarkFolder)",
						"group": "2_modification@0"
					},
					{
						"command": "SIMPLE-BOOKMARK.createfolder",
						"when": "view == SIMPLE-BOOKMARK && viewItem == bookmarkFolder",
						"group": "2_modification@1"
					},
					{
						"command": "SIMPLE-BOOKMARK.createfile",
						"when": "view == SIMPLE-BOOKMARK && viewItem == bookmarkFolder",
						"group": "2_modification@2"
					},
					{
						"command": "SIMPLE-BOOKMARK.removeitem",
						"when": "view == SIMPLE-BOOKMARK",
						"group": "4_danger@1"
					},
					{
						"command": "SIMPLE-BOOKMARK.removeitem",
						"when": "view == SIMPLE-BOOKMARK",
						"group": "inline"
					},
					{
						"command": "SIMPLE-BOOKMARK.renamebookmark",
						"when": "view == SIMPLE-BOOKMARK",
						"group": "inline"
					}
				],
				"explorer/context": [
					{
						"command": "SIMPLE-BOOKMARK.additem",
						"when": "explorerResourceIsFolder || explorerResourceIsFile",
						"group": "2_workspace@1"
					}
				]
			},
			"configuration": {
				"title": "SIMPLE-BOOKMARK",
				"properties": {
					"SIMPLE-BOOKMARK.autoRefresh": {
						"type": "boolean",
						"default": true,
						"description": "Automatically refresh bookmarks when files change"
					},
					"SIMPLE-BOOKMARK.showSyncStatus": {
						"type": "boolean",
						"default": true,
						"description": "Show synchronization status in bookmark items"
					},
					"SIMPLE-BOOKMARK.confirmDelete": {
						"type": "boolean",
						"default": true,
						"description": "Confirm before removing bookmarks"
					}
				}
			}
		},
		"scripts": {
			"watch": "tsc -watch -p .",
			"compile": "tsc -p .",
			"vsce": "tsc -p . && vsce package",
			"gcloud-deploy": "node .node/gcloud.cjs --full-deploy",
			"npm-reset": "pwsh -NoProfile -Command \"try { Stop-Process -Name node -Force -ErrorAction SilentlyContinue } catch {}; Start-Sleep -Milliseconds 200; if (Test-Path 'node_modules') { cmd /c 'rd /s /q \\\"node_modules\\\"' } ; if (Test-Path 'package-lock.json') { cmd /c 'del /f /q \\\"package-lock.json\\\"' } ; npm install\""
		},
		"dependencies": {
			"@babel/core": "^7.28.4",
			"glob": "^11.0.3",
			"terser": "^5.44.0"
		},
		"devDependencies": {
			"@types/glob": "^9.0.0",
			"@types/mocha": "^10.0.10",
			"@types/node": "^24.5.2",
			"@types/vscode": "^1.104.0",
			"@typescript-eslint/eslint-plugin": "^8.44.0",
			"@typescript-eslint/parser": "^8.44.0",
			"@vscode/vsce": "^3.6.0",
			"eslint": "^9.35.0",
			"mocha": "^11.7.2",
			"typescript": "^5.9.2",
			"@vscode/test-electron": "^2.5.2"
		}
	}

================================================================================================================================================================================================================================================
